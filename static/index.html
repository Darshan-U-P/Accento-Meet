<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>LightMeet — Demo</title>
  <style>
    body { font-family: system-ui, sans-serif; padding: 18px; max-width:900px; margin:auto; }
    .row { display:flex; gap:8px; margin-bottom:8px; align-items:center; }
    select, input { padding:6px; }
    #local, #remote { width:100%; }
    .controls { margin-top:12px; }
    .status { font-size:0.9rem; color: #444; margin-top:6px; }
  </style>
</head>
<body>
  <h2>LightMeet — WebRTC demo (Render)</h2>

  <div class="row">
    <label>Room ID: <input id="roomId" placeholder="room-1"></label>
    <label>Your ID: <input id="clientId" placeholder="random-id"></label>
    <button id="joinBtn">Join Room</button>
    <button id="leaveBtn" disabled>Leave</button>
  </div>

  <div class="row">
    <label>Mic:
      <select id="audioIn"></select>
    </label>
    <label>Output:
      <select id="audioOut"></select>
    </label>
    <label>
      <input id="muteLocal" type="checkbox"> Mute mic
    </label>
  </div>

  <div class="controls">
    <button id="callBtn" disabled>Start Call</button>
    <button id="hangBtn" disabled>Hangup</button>
  </div>

  <div class="status" id="status">Not connected</div>

  <h3>Local</h3>
  <audio id="local" autoplay muted></audio>

  <h3>Remote</h3>
  <audio id="remote" autoplay></audio>

<script>
const serverBase = location.origin; // works when served from same domain
let ws = null;
let pc = null;
let localStream = null;
let roomId = null;
let clientId = null;
const audioInSelect = document.getElementById('audioIn');
const audioOutSelect = document.getElementById('audioOut');
const localAudio = document.getElementById('local');
const remoteAudio = document.getElementById('remote');
const joinBtn = document.getElementById('joinBtn');
const leaveBtn = document.getElementById('leaveBtn');
const callBtn = document.getElementById('callBtn');
const hangBtn = document.getElementById('hangBtn');
const status = document.getElementById('status');
const muteLocal = document.getElementById('muteLocal');

function log(s){ console.log(s); status.innerText = s; }

// device enumeration
async function populateDevices() {
  const devices = await navigator.mediaDevices.enumerateDevices();
  audioInSelect.innerHTML = '';
  audioOutSelect.innerHTML = '';
  devices.forEach(d => {
    const opt = document.createElement('option');
    opt.value = d.deviceId;
    opt.text = (d.label || d.kind + ' ' + d.deviceId);
    if (d.kind === 'audioinput') audioInSelect.appendChild(opt);
    if (d.kind === 'audiooutput') audioOutSelect.appendChild(opt);
  });
}
populateDevices();
navigator.mediaDevices.ondevicechange = populateDevices;

// join/leave room (open websocket)
joinBtn.onclick = async ()=>{
  roomId = document.getElementById('roomId').value || 'room-1';
  clientId = document.getElementById('clientId').value || Math.random().toString(36).slice(2,9);
  const wsUrl = `${location.protocol === 'https:' ? 'wss' : 'ws'}://${location.host}/ws/${encodeURIComponent(roomId)}/${encodeURIComponent(clientId)}`;
  ws = new WebSocket(wsUrl);
  ws.onopen = ()=> {
    log('WebSocket connected to room ' + roomId);
    joinBtn.disabled = true;
    leaveBtn.disabled = false;
    callBtn.disabled = false;
  };
  ws.onmessage = async (ev) => {
    const msg = JSON.parse(ev.data);
    const from = msg.from;
    const type = msg.type;
    const payload = msg.payload || {};
    // handle signaling messages
    if (type === 'offer') {
      await ensurePeerConnection();
      await pc.setRemoteDescription(new RTCSessionDescription(payload));
      const answer = await pc.createAnswer();
      await pc.setLocalDescription(answer);
      ws.send(JSON.stringify({ to: from, type: 'answer', payload: pc.localDescription }));
      log('Received offer, sent answer');
    } else if (type === 'answer') {
      await pc.setRemoteDescription(new RTCSessionDescription(payload));
      log('Received answer');
    } else if (type === 'ice') {
      try {
        await pc.addIceCandidate(payload);
      } catch (e) {
        console.warn('ICE add error', e);
      }
    } else if (type === 'peer-joined') {
      // optionally start call to new peer
      log('Peer joined: ' + payload.client_id);
    } else if (type === 'peer-left') {
      log('Peer left: ' + payload.client_id);
    } else if (type === 'error') {
      console.warn('server error', payload.message);
    }
  };
  ws.onclose = ()=> {
    log('WebSocket closed');
    joinBtn.disabled = false;
    leaveBtn.disabled = true;
    callBtn.disabled = true;
  };
};

// leave room
leaveBtn.onclick = async ()=>{
  if (ws) ws.close();
  ws = null;
  joinBtn.disabled = false;
  leaveBtn.disabled = true;
  callBtn.disabled = true;
  hangup();
};

// start local capture + create offer to all peers (simple mesh: broadcast offer)
callBtn.onclick = async ()=>{
  await ensureLocalMedia();
  await ensurePeerConnection();
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  // broadcast offer to room (server will forward "offer" to others)
  ws.send(JSON.stringify({ type: 'offer', payload: pc.localDescription }));
  log('Offer created and sent');
  callBtn.disabled = true;
  hangBtn.disabled = false;
};

// hangup
hangBtn.onclick = ()=>{
  hangup();
  log('Call ended');
};

async function ensureLocalMedia(){
  if (localStream) return;
  const constraints = {
    audio: { deviceId: audioInSelect.value ? { exact: audioInSelect.value } : undefined },
    video: false
  };
  localStream = await navigator.mediaDevices.getUserMedia(constraints);
  localAudio.srcObject = localStream;
  if (muteLocal.checked) {
    localStream.getAudioTracks().forEach(t=>t.enabled=false);
  }
}

async function ensurePeerConnection(){
  if (pc) return;
  pc = new RTCPeerConnection({
    iceServers: [{ urls: "stun:stun.l.google.com:19302" }]
  });

  // send ICE to signaling server (we attach no "to" so server can broadcast or you can set to a specific peer)
  pc.onicecandidate = (e) => {
    if (!e.candidate) return;
    ws.send(JSON.stringify({ type: 'ice', payload: e.candidate }));
  };

  pc.ontrack = (e) => {
    // remote audio stream
    remoteAudio.srcObject = e.streams[0];
  };

  // attach local tracks
  await ensureLocalMedia();
  localStream.getTracks().forEach(track => pc.addTrack(track, localStream));
}

// hangup/cleanup
function hangup(){
  if (pc) {
    pc.getSenders().forEach(s => { try { s.track && s.track.stop(); } catch(e){} });
    pc.close();
    pc = null;
  }
  if (localStream) {
    localStream.getTracks().forEach(t=>t.stop());
    localStream = null;
    localAudio.srcObject = null;
  }
  hangBtn.disabled = true;
  callBtn.disabled = false;
}
</script>
</body>
</html>
