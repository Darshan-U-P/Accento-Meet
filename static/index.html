<!doctype html>
<html>
<head>
  <meta charset="utf-8" />
  <title>Mini Meet — Host/User Demo</title>
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <style>
    body{font-family:Arial,Helvetica,sans-serif;background:#0b1220;color:#e6eef6;margin:0;padding:12px}
    .app{max-width:1100px;margin:0 auto}
    header{display:flex;gap:12px;align-items:center}
    input,button,select{padding:8px;border-radius:8px;border:1px solid rgba(255,255,255,0.06);background:#0f1724;color:inherit}
    button{cursor:pointer;background:#4f46e5;color:#fff;border:none}
    .controls{display:flex;gap:8px;margin:10px 0;flex-wrap:wrap}
    .main{display:flex;gap:12px}
    .stage{flex:1;background:#081022;padding:12px;border-radius:10px}
    .sidebar{width:320px;background:#071225;padding:12px;border-radius:10px}
    #videos{display:grid;grid-template-columns:repeat(auto-fill,minmax(200px,1fr));gap:10px}
    .tile{position:relative;border-radius:8px;background:#000;height:150px;overflow:hidden}
    video{width:100%;height:100%;object-fit:cover}
    .label{position:absolute;left:8px;bottom:8px;background:rgba(0,0,0,0.5);padding:4px 8px;border-radius:999px;font-size:12px}
    .host-badge{background:#eab308;color:#08111a;padding:4px 8px;border-radius:999px;margin-left:6px;font-size:11px}
    .participant{display:flex;justify-content:space-between;align-items:center;padding:8px;border-radius:8px;margin-bottom:6px;background:rgba(255,255,255,0.02)}
    .small{font-size:12px;color:#9aa4b2}
    .muted{opacity:0.6}
  </style>
</head>
<body>
  <div class="app">
    <header>
      <h2>Mini Meet — Host/User</h2>
      <div class="small">Demo: host controls (mute/kick/make-host)</div>
    </header>

    <div class="controls">
      <label>Name: <input id="displayName" value="Guest"/></label>
      <label>Room: <input id="roomId" value="testroom"/></label>
      <button id="joinBtn">Join Room</button>
      <button id="leaveBtn" disabled>Leave</button>

      <div style="flex:1"></div>

      <button id="muteBtn" disabled>Mute</button>
      <button id="cameraBtn" disabled>Stop Camera</button>
      <button id="shareBtn" disabled>Share Screen</button>
    </div>

    <div class="main">
      <section class="stage">
        <div id="videos"></div>
        <div class="small" style="margin-top:8px">Your id: <span id="myId">—</span> • <span id="roleLabel">—</span></div>
      </section>

      <aside class="sidebar">
        <h3>Participants</h3>
        <div id="participantsList"></div>
        <h4>Chat</h4>
        <div id="chatLog" style="height:200px;overflow:auto;background:rgba(255,255,255,0.02);padding:8px;border-radius:8px"></div>
        <div style="display:flex;gap:8px;margin-top:8px">
          <input id="chatInput" placeholder="Message..." style="flex:1"/>
          <button id="sendChat" disabled>Send</button>
        </div>
      </aside>
    </div>
  </div>

<script>
/* Frontend supporting host/user roles and host controls.
   Works with server.py message format:
   - client sends initial {"type":"join","displayName":"Alice"}
   - server replies {"type":"welcome","client_id":..., "participants": [...], "host_id": ...}
   - server broadcasts participant changes, participants-update
   - host actions use {"type":"action","action":"mute","target":"id"}
   - server sends commands to clients: {"type":"command","cmd":"force-mute"} or "you-are-kicked"
*/

const displayNameInput = document.getElementById('displayName');
const roomInput = document.getElementById('roomId');
const joinBtn = document.getElementById('joinBtn');
const leaveBtn = document.getElementById('leaveBtn');
const myIdLabel = document.getElementById('myId');
const roleLabel = document.getElementById('roleLabel');
const videos = document.getElementById('videos');
const participantsList = document.getElementById('participantsList');
const chatLog = document.getElementById('chatLog');
const chatInput = document.getElementById('chatInput');
const sendChat = document.getElementById('sendChat');

const muteBtn = document.getElementById('muteBtn');
const cameraBtn = document.getElementById('cameraBtn');
const shareBtn = document.getElementById('shareBtn');

let ws = null;
let myId = null;
let hostId = null;
let localStream = null;
let pcs = {};
let videoEls = {};
let senders = {};
let isMuted = false;
let camOn = true;
const ICE_SERVERS = [{ urls: "stun:stun.l.google.com:19302" }];

function logChat(text) {
  const d = document.createElement('div'); d.textContent = text; chatLog.appendChild(d); chatLog.scrollTop = chatLog.scrollHeight;
}

/* UI helpers */
function setRoleLabel() {
  if (!myId) { roleLabel.textContent = '—'; return; }
  roleLabel.textContent = (myId === hostId) ? 'Host' : 'Participant';
}

/* Participant list rendering */
function renderParticipants(participants) {
  participantsList.innerHTML = '';
  participants.forEach(p => {
    const el = document.createElement('div'); el.className = 'participant';
    const left = document.createElement('div');
    left.innerHTML = `<strong>${p.displayName}</strong> <span class="small">(${p.id})</span>`;
    if (p.is_host) {
      const hb = document.createElement('span'); hb.className='host-badge'; hb.textContent='HOST';
      left.appendChild(hb);
    }
    el.appendChild(left);

    const right = document.createElement('div');

    // If I am host, show controls for others (cannot act on self except transfer)
    if (myId && myId === hostId && p.id !== myId) {
      const mute = document.createElement('button'); mute.textContent='Mute'; mute.style.marginRight='6px';
      mute.onclick = () => sendAction('mute', p.id);
      right.appendChild(mute);

      const kick = document.createElement('button'); kick.textContent='Kick'; kick.style.marginRight='6px';
      kick.onclick = () => {
        if (confirm(`Kick ${p.displayName}?`)) sendAction('kick', p.id);
      };
      right.appendChild(kick);

      const makeHost = document.createElement('button'); makeHost.textContent='Make Host';
      makeHost.onclick = () => {
        if (confirm(`Make ${p.displayName} host?`)) sendAction('make-host', p.id);
      };
      right.appendChild(makeHost);
    } else {
      // non-host view: if the participant is self show small badge
      if (p.id === myId) {
        const me = document.createElement('span'); me.className='small'; me.textContent='You';
        right.appendChild(me);
      }
    }

    el.appendChild(right);
    participantsList.appendChild(el);
  });
}

/* WebSocket / signaling */

function sendWS(payload) {
  if (!ws || ws.readyState !== WebSocket.OPEN) return;
  ws.send(JSON.stringify(payload));
}

async function startLocalMedia() {
  try {
    localStream = await navigator.mediaDevices.getUserMedia({ video: true, audio: true });
    addOrReplaceLocalTile(localStream);
    muteBtn.disabled = cameraBtn.disabled = shareBtn.disabled = sendChat.disabled = false;
  } catch (e) {
    alert('Camera/microphone access required');
  }
}

function addOrReplaceLocalTile(stream) {
  const id = 'local';
  if (!videoEls[id]) {
    const tile = document.createElement('div'); tile.className='tile'; tile.id=`tile-${id}`;
    const v = document.createElement('video'); v.autoplay = true; v.muted = true; v.playsInline = true; v.id=`video-${id}`;
    tile.appendChild(v);
    const label = document.createElement('div'); label.className='label'; label.textContent='You';
    tile.appendChild(label);
    videos.prepend(tile);
    videoEls[id] = v;
  }
  videoEls[id].srcObject = stream;
}

function addRemoteTile(peerId, stream) {
  if (videoEls[peerId]) {
    videoEls[peerId].srcObject = stream;
    return;
  }
  const tile = document.createElement('div'); tile.className='tile'; tile.id=`tile-${peerId}`;
  const v = document.createElement('video'); v.autoplay = true; v.playsInline = true; v.id=`video-${peerId}`;
  tile.appendChild(v);
  const label = document.createElement('div'); label.className='label'; label.textContent = peerId;
  tile.appendChild(label);
  videos.appendChild(tile);
  videoEls[peerId] = v;
  v.srcObject = stream;
}

function removeRemoteTile(peerId) {
  const el = document.getElementById(`tile-${peerId}`);
  if (el) el.remove();
  if (videoEls[peerId]) delete videoEls[peerId];
}

/* Handle server messages */
async function handleSignal(msg) {
  switch(msg.type) {
    case 'welcome':
      myId = msg.client_id;
      hostId = msg.host_id;
      myIdLabel.textContent = myId;
      setRoleLabel();
      renderParticipants(msg.participants || []);
      // Create offers to existing participants (except self)
      for (const p of msg.participants || []) {
        if (p.id !== myId) await createOffer(p.id);
      }
      break;

    case 'participant-joined':
      renderParticipants_append(msg.participant);
      logChatSystem(`${msg.participant.displayName} joined`);
      break;

    case 'participants-update':
      hostId = msg.host_id;
      setRoleLabel();
      renderParticipants(msg.participants || []);
      break;

    case 'participant-left':
      logChatSystem(`${msg.displayName} left`);
      removeRemoteTile(msg.id);
      break;

    case 'offer':
      if (msg.to && msg.to !== myId) return;
      await handleOffer(msg);
      break;

    case 'answer':
      if (msg.to && msg.to !== myId) return;
      await handleAnswer(msg);
      break;

    case 'ice-candidate':
      if (msg.to && msg.to !== myId) return;
      await handleRemoteICE(msg);
      break;

    case 'chat':
      logChat(`[${msg.from}] ${msg.text}`);
      break;

    case 'command':
      // commands from server: force-mute, you-are-kicked, etc.
      if (msg.cmd === 'force-mute') {
        // mute local mic
        if (localStream) {
          localStream.getAudioTracks().forEach(t => t.enabled = false);
          isMuted = true; muteBtn.textContent = 'Unmute';
        }
        logChatSystem(`System: You were asked to mute by ${msg.from || 'host'}`);
      } else if (msg.cmd === 'you-are-kicked') {
        logChatSystem('System: You were kicked by host.');
        // Close websocket and cleanup
        if (ws) ws.close();
        cleanupAll();
      }
      break;

    case 'room-lock':
      // optional: show lock state
      logChatSystem(`Room locked: ${msg.locked}`);
      break;

    case 'system':
      if (msg.message) logChatSystem(msg.message);
      break;

    case 'error':
      console.warn('Server error:', msg.message);
      break;

    default:
      console.log('Unknown message', msg);
  }
}

/* helpers */
function renderParticipants_append(p) {
  // fetch current list from DOM isn't tracked here; better to request participants update from server
  // but server broadcasts participants-update on joins; we'll request no-op here
  // fallback: just add tile label for id
  logChatSystem(`${p.displayName} joined (id: ${p.id})`);
}

/* WebRTC functions */
function makePeerConnection(peerId) {
  const pc = new RTCPeerConnection({ iceServers: ICE_SERVERS });
  if (localStream) {
    senders[peerId] = {};
    for (const t of localStream.getTracks()) {
      const sender = pc.addTrack(t, localStream);
      if (t.kind === 'video') senders[peerId].videoSender = sender;
      if (t.kind === 'audio') senders[peerId].audioSender = sender;
    }
  }

  pc.onicecandidate = ev => {
    if (ev.candidate) sendWS({ type: 'ice-candidate', to: peerId, candidate: ev.candidate });
  };

  pc.ontrack = ev => {
    addRemoteTile(peerId, ev.streams[0]);
  };

  pc.onconnectionstatechange = () => {
    if (pc.connectionState === 'failed' || pc.connectionState === 'closed') {
      try { pc.close(); } catch(e){}
      delete pcs[peerId];
      removeRemoteTile(peerId);
    }
  };

  pcs[peerId] = pc;
  return pc;
}

async function createOffer(peerId) {
  if (!localStream) await startLocalMedia();
  if (pcs[peerId]) return;
  const pc = makePeerConnection(peerId);
  const offer = await pc.createOffer();
  await pc.setLocalDescription(offer);
  sendWS({ type: 'offer', to: peerId, sdp: offer.sdp, sdpType: offer.type, from: myId });
}

async function handleOffer(msg) {
  const from = msg.from;
  if (!from) return;
  if (!pcs[from]) makePeerConnection(from);
  const pc = pcs[from];
  await pc.setRemoteDescription({ type: 'offer', sdp: msg.sdp });
  const answer = await pc.createAnswer();
  await pc.setLocalDescription(answer);
  sendWS({ type: 'answer', to: from, sdp: answer.sdp, sdpType: answer.type, from: myId });
}

async function handleAnswer(msg) {
  const from = msg.from;
  if (!from) return;
  const pc = pcs[from];
  if (!pc) return;
  await pc.setRemoteDescription({ type: 'answer', sdp: msg.sdp });
}

async function handleRemoteICE(msg) {
  const from = msg.from;
  const pc = pcs[from];
  if (!pc) return;
  try {
    await pc.addIceCandidate(msg.candidate);
  } catch (e) {
    console.warn('ICE add error', e);
  }
}

/* Host action helper */
function sendAction(action, target) {
  sendWS({ type: 'action', action, target });
}

/* UI actions */
joinBtn.onclick = async () => {
  if (ws) return;
  const name = displayNameInput.value.trim() || 'Guest';
  const room = roomInput.value.trim() || 'testroom';
  const protocol = (location.protocol === 'https:') ? 'wss' : 'ws';
  const url = `${protocol}://${location.host}/ws/${encodeURIComponent(room)}`;
  ws = new WebSocket(url);

  ws.onopen = () => {
    // immediately send join message
    sendWS({ type: 'join', displayName: name });
    joinBtn.disabled = true;
    leaveBtn.disabled = false;
  };

  ws.onmessage = evt => {
    try { const msg = JSON.parse(evt.data); handleSignal(msg); } catch(e){console.error(e);}
  };
  ws.onclose = () => {
    cleanupAll();
  };
  ws.onerror = e => console.error('ws error', e);

  await startLocalMedia();
};

leaveBtn.onclick = () => {
  if (ws) ws.close();
  cleanupAll();
};

muteBtn.onclick = () => {
  if (!localStream) return;
  isMuted = !isMuted;
  localStream.getAudioTracks().forEach(t => t.enabled = !isMuted);
  muteBtn.textContent = isMuted ? 'Unmute' : 'Mute';
};

cameraBtn.onclick = () => {
  if (!localStream) return;
  camOn = !camOn;
  localStream.getVideoTracks().forEach(t => t.enabled = camOn);
  cameraBtn.textContent = camOn ? 'Stop Camera' : 'Start Camera';
};

shareBtn.onclick = async () => {
  if (!ws) { alert('Join a room first'); return; }
  try {
    const screenStream = await navigator.mediaDevices.getDisplayMedia({ video: true });
    const screenTrack = screenStream.getVideoTracks()[0];
    // replace for each peer
    for (const peerId of Object.keys(senders)) {
      const s = senders[peerId].videoSender;
      if (s) await s.replaceTrack(screenTrack);
    }
    addOrReplaceLocalTile(screenStream);
    screenTrack.onended = async () => {
      if (!localStream) return;
      for (const peerId of Object.keys(senders)) {
        const s = senders[peerId].videoSender;
        if (s) await s.replaceTrack(localStream.getVideoTracks()[0]);
      }
      addOrReplaceLocalTile(localStream);
    };
  } catch (e) { console.error('screen share failed', e); }
};

/* Chat */
sendChat.onclick = () => {
  const t = chatInput.value.trim();
  if (!t || !ws) return;
  sendWS({ type: 'chat', text: t });
  logChat(`[me] ${t}`);
  chatInput.value = '';
};

/* System log helpers */
function logChat(msg) { logChatGeneric(msg); }
function logChatSystem(msg) { logChatGeneric(`System: ${msg}`); }
function logChatGeneric(msg) {
  const d = document.createElement('div'); d.textContent = msg; chatLog.appendChild(d); chatLog.scrollTop = chatLog.scrollHeight;
}

/* Cleanup */
function cleanupAll() {
  myId = null; hostId = null;
  myIdLabel.textContent = '—'; roleLabel.textContent = '—';
  // close pcs
  Object.values(pcs).forEach(pc => { try{pc.close()}catch(e){} });
  pcs = {};
  // stop local
  if (localStream) {
    localStream.getTracks().forEach(t => t.stop());
    localStream = null;
  }
  // remove tiles except local
  Object.keys(videoEls).forEach(k => {
    if (k !== 'local') removeRemoteTile(k);
    else {
      // remove local tile
      const el = document.getElementById('tile-local');
      if (el) el.remove();
      delete videoEls['local'];
    }
  });
  if (ws) { try{ ws.close(); } catch(e){} ws = null; }
  joinBtn.disabled = false; leaveBtn.disabled = true;
  muteBtn.disabled = cameraBtn.disabled = shareBtn.disabled = sendChat.disabled = true;
}
</script>
</body>
</html>
